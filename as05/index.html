<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <title>Scroll Trigger Demo – Flip Card / Focus Mode / Underline</title>
  <style>
    :root {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      color: #222;
      background: #f4f4f4;
      line-height: 1.6;
    }

    body {
      margin: 0;
    }

    header {
      padding: 3rem 10vw 2rem;
      background: #111;
      color: #f9f9f9;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      margin: 0 0 0.5rem;
      font-size: 1.6rem;
    }

    header p {
      margin: 0;
      font-size: 0.95rem;
      opacity: 0.8;
    }

    main {
      padding: 2rem 10vw 4rem;
    }

    section {
      margin-bottom: 5rem;
    }

    h2 {
      margin-top: 0;
      font-size: 1.4rem;
    }

    /* ===== 1. Flip Card 區塊 ===== */

    .flip-card-wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 80vh; /* 確保需要捲動才會進入視窗中間 */
    }

    .flip-card {
      width: 320px;
      height: 200px;
      perspective: 1000px;
    }

    .flip-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
      transition: transform 0.8s ease;
    }

    .flip-card.flipped .flip-card-inner {
      transform: rotateY(180deg);
    }

    .flip-card-face {
      position: absolute;
      inset: 0;
      backface-visibility: hidden;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 18px 35px rgba(0, 0, 0, 0.25);
    }

    .flip-card-front {
      background: url("https://images.pexels.com/photos/158607/cairn-fog-mystical-background-158607.jpeg?auto=compress&cs=tinysrgb&w=800")
        center / cover no-repeat;
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      padding: 1rem;
      color: #fff;
    }

    .flip-card-front span {
      background: rgba(0, 0, 0, 0.6);
      padding: 0.4rem 0.7rem;
      border-radius: 999px;
      font-size: 0.9rem;
    }

    .flip-card-back {
      background: #ffffff;
      transform: rotateY(180deg);
      padding: 1.4rem;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }

    .flip-card-back h3 {
      margin-top: 0;
      margin-bottom: 0.5rem;
    }

    .flip-card-back p {
      margin: 0;
      font-size: 0.95rem;
      color: #444;
    }

    /* ===== 2. Focus Mode 章節高亮 ===== */

    .focus-section {
      padding: 2.5rem 2rem;
      border-radius: 18px;
      margin-bottom: 2.5rem;
      background: #ffffff;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.05);
      opacity: 0.45;
      transform: scale(0.98);
      transition:
        opacity 0.4s ease,
        transform 0.4s ease,
        box-shadow 0.4s ease,
        filter 0.4s ease;
    }

    .focus-section.in-focus {
      opacity: 1;
      transform: scale(1);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.16);
      filter: saturate(1.05);
    }

    .focus-section h3 {
      margin-top: 0;
      margin-bottom: 0.8rem;
    }

    /* ===== 3. Scroll underline for span ===== */

    .scroll-text {
      font-size: 1.05rem;
      max-width: 720px;
    }

    .underline-target {
      position: relative;
      background-image: linear-gradient(currentColor, currentColor);
      background-position: 0 100%;
      background-repeat: no-repeat;
      background-size: 0% 2px; /* 一開始沒有底線 */
    }

    .underline-target.visible {
      animation: underline-grow 0.45s ease forwards;
    }

    @keyframes underline-grow {
      from {
        background-size: 0% 2px;
      }
      to {
        background-size: 100% 2px;
      }
    }

    /* 小提示樣式 */
    .hint {
      font-size: 0.9rem;
      color: #666;
      margin-top: 0.5rem;
    }

    footer {
      text-align: center;
      padding: 2rem 0 1rem;
      font-size: 0.85rem;
      color: #777;
    }

    @media (max-width: 768px) {
      header {
        padding-inline: 6vw;
      }

      main {
        padding-inline: 6vw;
      }

      .focus-section {
        padding-inline: 1.4rem;
      }
    }
  </style>
</head>
<body>
  <header>
    <h1>Scroll 觸發的三種動態效果示範</h1>
    <p>
      包含翻卡（圖片 → 文字）、章節 Focus mode、以及捲動至
      <span>&lt;span&gt;</span> 時出現的底線動畫。
    </p>
  </header>

  <main>
    <!-- 1. Flip Card 區塊 -->
    <section id="flip-card-section">
      <h2>1. 翻卡 Flip Card（捲動到視窗中央自動翻面）</h2>
      <p class="hint">向下捲動，當卡片接近視窗中央時，會自動翻成文字面。</p>

      <div class="flip-card-wrapper">
        <div class="flip-card">
          <div class="flip-card-inner">
            <div class="flip-card-face flip-card-front">
              <span>向下捲動，看看會發生什麼。</span>
            </div>
            <div class="flip-card-face flip-card-back">
              <h3>翻卡完成！</h3>
              <p>
                這張卡片的前面是圖片，當它捲動到視窗中間附近時，
                會自動觸發翻面，顯示文字內容。這模擬的是：
                當重要圖像進入「閱讀者視線中心」後，主動提供更深一層的資訊。
              </p>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- 2. Focus Mode 章節 -->
    <section id="focus-mode-section">
      <h2>2. Section Focus mode（正在閱讀的段落被高亮）</h2>
      <p class="hint">
        繼續向下捲動，可以看到「目前停留的段落」會變亮、放大，
        其他段落則會略為變暗，幫助讀者集中注意力。
      </p>

      <article class="focus-section">
        <h3>段落 A：建立背景</h3>
        <p>
          當資訊量變得越來越龐大時，閱讀者在一個畫面上可能同時看到好幾個段落。
          Focus mode 的概念，是當某一段落進入主要視窗區域時，
          讓它在視覺上稍微「跳出來」，例如增加亮度、對比、或微幅放大。
        </p>
      </article>

      <article class="focus-section">
        <h3>段落 B：引導視線</h3>
        <p>
          在這個示範中，我們利用 <code>IntersectionObserver</code>
          定期偵測哪一個段落目前位在畫面中間附近，並替它加上
          <code>.in-focus</code> 的 class。CSS 則會讓這個段落的
          <strong>透明度變高、陰影變深、飽和度稍微提高</strong>。
        </p>
      </article>

      <article class="focus-section">
        <h3>段落 C：降低干擾</h3>
        <p>
          對長篇文章或多媒體專題來說，這種效果有助於讓讀者理解：
          「我現在正在哪一個段落」，也能降低其他區塊帶來的干擾，
          尤其當畫面上同時有圖片、文字、甚至互動元素時。
        </p>
      </article>

      <article class="focus-section">
        <h3>段落 D：收尾與延伸</h3>
        <p>
          當段落的底部即將離開畫面時，下一個段落會被判定為新的焦點；
          如此便形成一種「閱讀節奏」，讓畫面在使用者捲動的過程中，
          不斷提醒：現在的注意力應該放在哪裡。
        </p>
      </article>
    </section>

    <!-- 3. Span underline on scroll -->
    <section id="underline-section">
      <h2>3. 捲動觸發文字底線（自訂效果）</h2>
      <p class="hint">
        以下段落中有幾個關鍵字被
        <code>&lt;span class="underline-target"&gt;</code>
        包起來，當它們捲動到可視範圍時，會自動出現底線動畫。
      </p>

      <p class="scroll-text">
        在長篇閱讀中，適度地<strong>標記關鍵詞</strong>可以幫助使用者抓住主線。
        例如：當讀者捲動到
        <span class="underline-target">重要概念</span>
        或
        <span class="underline-target">轉折句</span>
        所在的位置時，我們可以利用細微的動畫，
        <span class="underline-target">像是底線展開</span>，
        來提醒：「這一段話值得多停留一點時間」。
      </p>

      <p class="scroll-text">
        相較於突兀的配色或大量粗體，這種
        <span class="underline-target">動態式標記</span>
        不會打斷閱讀流，卻能在讀者自然的捲動行為中，
        悄悄地<strong>喚起注意力</strong>。同時，也讓設計有更多層次的表現空間，
        而不是只有靜態的邊線或底色。
      </p>
    </section>
  </main>

  <footer>
    Scroll interaction demo – flip card, focus mode, underline on scroll.
  </footer>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      /* ===== 1. Flip Card：捲動到視窗中間附近時翻面 ===== */
      const flipCard = document.querySelector(".flip-card");

      if (flipCard) {
        const flipObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                flipCard.classList.add("flipped");
              }
            });
          },
          {
            threshold: 0.6, // 60% 卡片進入視窗，就算是在「中間附近」
          }
        );

        flipObserver.observe(flipCard);
      }

      /* ===== 2. Focus Mode：目前視窗內的 section 高亮 ===== */
      const focusSections = document.querySelectorAll(".focus-section");

      if (focusSections.length > 0) {
        const focusObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                // 先移除所有 section 的 in-focus
                focusSections.forEach((sec) =>
                  sec.classList.remove("in-focus")
                );
                // 將目前進入中心區域的 section 設為 in-focus
                entry.target.classList.add("in-focus");
              }
            });
          },
          {
            threshold: 0.6, // section 有 60% 在畫面內時，視為正在閱讀
          }
        );

        focusSections.forEach((sec) => focusObserver.observe(sec));
      }

      /* ===== 3. Span underline：捲動到可視範圍時底線展開 ===== */
      const underlineTargets = document.querySelectorAll(".underline-target");

      if (underlineTargets.length > 0) {
        const underlineObserver = new IntersectionObserver(
          (entries) => {
            entries.forEach((entry) => {
              if (entry.isIntersecting) {
                entry.target.classList.add("visible");
                // 加一次就好，可以取消監看（避免重複動畫）
                underlineObserver.unobserve(entry.target);
              }
            });
          },
          {
            root: null,
            // 提前一點觸發，讓底線在完全看見前就開始動畫
            rootMargin: "0px 0px -15% 0px",
            threshold: 0.2,
          }
        );

        underlineTargets.forEach((span) =>
          underlineObserver.observe(span)
        );
      }
    });
  </script>
</body>
</html>
